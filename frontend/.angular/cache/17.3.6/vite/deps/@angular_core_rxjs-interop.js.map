{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v17.3.6\r\n * (c) 2010-2024 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\n\r\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @developerPreview\r\n */\r\nfunction takeUntilDestroyed(destroyRef) {\r\n    if (!destroyRef) {\r\n        assertInInjectionContext(takeUntilDestroyed);\r\n        destroyRef = inject(DestroyRef);\r\n    }\r\n    const destroyed$ = new Observable(observer => {\r\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\r\n        return unregisterFn;\r\n    });\r\n    return (source) => {\r\n        return source.pipe(takeUntil(destroyed$));\r\n    };\r\n}\r\n\r\n/**\r\n * Implementation of `OutputRef` that emits values from\r\n * an RxJS observable source.\r\n *\r\n * @internal\r\n */\r\nclass OutputFromObservableRef {\r\n    constructor(source) {\r\n        this.source = source;\r\n        this.destroyed = false;\r\n        this.destroyRef = inject(DestroyRef);\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n        });\r\n    }\r\n    subscribe(callbackFn) {\r\n        if (this.destroyed) {\r\n            throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected subscription to destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.');\r\n        }\r\n        // Stop yielding more values when the directive/component is already destroyed.\r\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\r\n            next: value => callbackFn(value),\r\n        });\r\n        return {\r\n            unsubscribe: () => subscription.unsubscribe(),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Declares an Angular output that is using an RxJS observable as a source\r\n * for events dispatched to parent subscribers.\r\n *\r\n * The behavior for an observable as source is defined as followed:\r\n *    1. New values are forwarded to the Angular output (next notifications).\r\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\r\n *       For example by using `catchError`.\r\n *    3. Completion notifications stop the output from emitting new values.\r\n *\r\n * @usageNotes\r\n * Initialize an output in your directive by declaring a\r\n * class field and initializing it with the `outputFromObservable()` function.\r\n *\r\n * ```ts\r\n * @Directive({..})\r\n * export class MyDir {\r\n *   nameChange$ = <some-observable>;\r\n *   nameChange = outputFromObservable(this.nameChange$);\r\n * }\r\n * ```\r\n *\r\n * @developerPreview\r\n */\r\nfunction outputFromObservable(observable, opts) {\r\n    ngDevMode && assertInInjectionContext(outputFromObservable);\r\n    return new OutputFromObservableRef(observable);\r\n}\r\n\r\n/**\r\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\r\n * to an observable.\r\n *\r\n * You can subscribe to the output via `Observable.subscribe` then.\r\n *\r\n * @developerPreview\r\n */\r\nfunction outputToObservable(ref) {\r\n    const destroyRef = ɵgetOutputDestroyRef(ref);\r\n    return new Observable(observer => {\r\n        // Complete the observable upon directive/component destroy.\r\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\r\n        // of an injection context.\r\n        destroyRef?.onDestroy(() => observer.complete());\r\n        const subscription = ref.subscribe(v => observer.next(v));\r\n        return () => subscription.unsubscribe();\r\n    });\r\n}\r\n\r\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @developerPreview\r\n */\r\nfunction toObservable(source, options) {\r\n    !options?.injector && assertInInjectionContext(toObservable);\r\n    const injector = options?.injector ?? inject(Injector);\r\n    const subject = new ReplaySubject(1);\r\n    const watcher = effect(() => {\r\n        let value;\r\n        try {\r\n            value = source();\r\n        }\r\n        catch (err) {\r\n            untracked(() => subject.error(err));\r\n            return;\r\n        }\r\n        untracked(() => subject.next(value));\r\n    }, { injector, manualCleanup: true });\r\n    injector.get(DestroyRef).onDestroy(() => {\r\n        watcher.destroy();\r\n        subject.complete();\r\n    });\r\n    return subject.asObservable();\r\n}\r\n\r\n/**\r\n * Get the current value of an `Observable` as a reactive `Signal`.\r\n *\r\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\r\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\r\n * have the most recent value emitted by the subscription, and will throw an error if the\r\n * `Observable` errors.\r\n *\r\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\r\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\r\n * does not include an `undefined` type.\r\n *\r\n * By default, the subscription will be automatically cleaned up when the current [injection\r\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\r\n * called during the construction of a component, the subscription will be cleaned up when the\r\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\r\n * passed instead.\r\n *\r\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\r\n * option can be specified instead, which disables the automatic subscription teardown. No injection\r\n * context is needed in this configuration as well.\r\n *\r\n * @developerPreview\r\n */\r\nfunction toSignal(source, options) {\r\n    ngDevMode &&\r\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\r\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\r\n    const requiresCleanup = !options?.manualCleanup;\r\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\r\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\r\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\r\n    // the same - the returned signal gives values of type `T`.\r\n    let state;\r\n    if (options?.requireSync) {\r\n        // Initially the signal is in a `NoValue` state.\r\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\r\n    }\r\n    else {\r\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\r\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\r\n    }\r\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\r\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\r\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\r\n    // consumer only needs to be notified when the `state` signal changes through the observable\r\n    // subscription. Additional context (related to async pipe):\r\n    // https://github.com/angular/angular/pull/50522.\r\n    const sub = source.subscribe({\r\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\r\n        error: error => {\r\n            if (options?.rejectErrors) {\r\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\r\n                // the error to end up as an uncaught exception.\r\n                throw error;\r\n            }\r\n            state.set({ kind: 2 /* StateKind.Error */, error });\r\n        },\r\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\r\n        // \"complete\".\r\n    });\r\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\r\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n    }\r\n    // Unsubscribe when the current context is destroyed, if requested.\r\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\r\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\r\n    // to either values or errors.\r\n    return computed(() => {\r\n        const current = state();\r\n        switch (current.kind) {\r\n            case 1 /* StateKind.Value */:\r\n                return current.value;\r\n            case 2 /* StateKind.Error */:\r\n                throw current.error;\r\n            case 0 /* StateKind.NoValue */:\r\n                // This shouldn't really happen because the error is thrown on creation.\r\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\r\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\r\n\r\n"],
  "mappings": "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",
  "names": []
}
